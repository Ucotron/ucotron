//! Entity resolution using structural + semantic similarity.
//!
//! Implements the Convergent mindset mode from Chain of Mindset (CoM):
//! given a set of candidate nodes (e.g., all nodes named "Apple"), cluster
//! them into distinct entities based on their **neighborhood structure**
//! (Jaccard similarity of 1-hop neighbors) combined with **embedding
//! similarity** (cosine similarity).
//!
//! ## Scoring Formula
//!
//! ```text
//! combined = 0.6 × jaccard(neighbors_a, neighbors_b) + 0.4 × cosine(emb_a, emb_b)
//! ```
//!
//! This weights structural context more heavily than raw semantic similarity,
//! which is critical for disambiguating homonyms (e.g., "Apple" the fruit vs.
//! "Apple" the company).

use crate::{NodeId, StorageEngine};
use anyhow::Result;
use std::collections::HashSet;

/// Weight for Jaccard (structural) similarity in the combined score.
const JACCARD_WEIGHT: f32 = 0.6;
/// Weight for cosine (semantic) similarity in the combined score.
const COSINE_WEIGHT: f32 = 0.4;

/// Default threshold for clustering: nodes with combined similarity below
/// this value are placed in separate clusters.
pub const DEFAULT_SIMILARITY_THRESHOLD: f32 = 0.5;

/// A cluster of nodes that are believed to refer to the same real-world entity.
#[derive(Debug, Clone)]
pub struct EntityCluster {
    /// Indices into the original candidate slice (not NodeIds).
    pub member_indices: Vec<usize>,
    /// NodeIds of the cluster members.
    pub member_ids: Vec<NodeId>,
}

/// Configuration for entity resolution.
#[derive(Debug, Clone)]
pub struct EntityResolutionConfig {
    /// Minimum combined similarity to merge two nodes into the same cluster.
    /// Range: 0.0 (merge everything) to 1.0 (never merge).
    pub threshold: f32,
}

impl Default for EntityResolutionConfig {
    fn default() -> Self {
        Self {
            threshold: DEFAULT_SIMILARITY_THRESHOLD,
        }
    }
}

/// Compute cosine similarity between two embedding vectors.
///
/// Assumes both vectors are L2-normalized (as generated by `data_gen`),
/// so cosine similarity equals their dot product. Returns 0.0 if either
/// vector is empty.
fn cosine_similarity(a: &[f32], b: &[f32]) -> f32 {
    if a.is_empty() || b.is_empty() || a.len() != b.len() {
        return 0.0;
    }
    a.iter().zip(b.iter()).map(|(x, y)| x * y).sum()
}

/// Compute Jaccard similarity between two sets of neighbor IDs.
///
/// Jaccard(A, B) = |A ∩ B| / |A ∪ B|
///
/// Returns 0.0 if both sets are empty (no neighbors).
fn jaccard_similarity(neighbors_a: &HashSet<NodeId>, neighbors_b: &HashSet<NodeId>) -> f32 {
    if neighbors_a.is_empty() && neighbors_b.is_empty() {
        return 0.0;
    }
    let intersection = neighbors_a.intersection(neighbors_b).count();
    let union = neighbors_a.union(neighbors_b).count();
    intersection as f32 / union as f32
}

/// Compute the combined structural + semantic similarity between two nodes.
///
/// Formula: `0.6 × jaccard(1-hop neighbors) + 0.4 × cosine(embeddings)`
///
/// The neighbor sets are obtained from the storage engine via `get_neighbors(id, 1)`.
///
/// # Arguments
/// * `engine` - Storage engine for neighbor lookups
/// * `node_a_id` - First node ID
/// * `node_a_embedding` - First node's embedding vector
/// * `neighbors_a` - Pre-fetched 1-hop neighbor IDs for node A
/// * `node_b_id` - Second node ID
/// * `node_b_embedding` - Second node's embedding vector
/// * `neighbors_b` - Pre-fetched 1-hop neighbor IDs for node B
pub fn structural_similarity(
    node_a_embedding: &[f32],
    neighbors_a: &HashSet<NodeId>,
    node_b_embedding: &[f32],
    neighbors_b: &HashSet<NodeId>,
) -> f32 {
    let jaccard = jaccard_similarity(neighbors_a, neighbors_b);
    let cosine = cosine_similarity(node_a_embedding, node_b_embedding);
    JACCARD_WEIGHT * jaccard + COSINE_WEIGHT * cosine
}

/// Resolve a set of candidate nodes into distinct entity clusters.
///
/// Uses single-linkage agglomerative clustering: two nodes are in the same
/// cluster if their combined similarity exceeds the threshold. If node A is
/// similar to B, and B is similar to C, all three end up in one cluster
/// (transitivity via union-find).
///
/// # Arguments
/// * `engine` - Storage engine for neighbor lookups
/// * `candidate_ids` - Node IDs to cluster (typically nodes with the same name/label)
/// * `config` - Similarity threshold and other settings
///
/// # Returns
/// A list of `EntityCluster`s. Each cluster contains the indices and IDs of
/// nodes that are believed to refer to the same entity.
pub fn resolve_entities<E: StorageEngine>(
    engine: &E,
    candidate_ids: &[NodeId],
    config: &EntityResolutionConfig,
) -> Result<Vec<EntityCluster>> {
    let n = candidate_ids.len();
    if n == 0 {
        return Ok(Vec::new());
    }
    if n == 1 {
        return Ok(vec![EntityCluster {
            member_indices: vec![0],
            member_ids: vec![candidate_ids[0]],
        }]);
    }

    // Pre-fetch embeddings and neighbor sets for all candidates
    let mut embeddings: Vec<Vec<f32>> = Vec::with_capacity(n);
    let mut neighbor_sets: Vec<HashSet<NodeId>> = Vec::with_capacity(n);

    for &cid in candidate_ids {
        let node = engine
            .get_node(cid)?
            .ok_or_else(|| anyhow::anyhow!("Node {} not found", cid))?;
        embeddings.push(node.embedding);

        let neighbors = engine.get_neighbors(cid, 1)?;
        let nset: HashSet<NodeId> = neighbors.iter().map(|n| n.id).collect();
        neighbor_sets.push(nset);
    }

    // Union-Find for clustering
    let mut parent: Vec<usize> = (0..n).collect();

    fn find(parent: &mut [usize], mut x: usize) -> usize {
        while parent[x] != x {
            parent[x] = parent[parent[x]]; // path compression
            x = parent[x];
        }
        x
    }

    fn union(parent: &mut [usize], a: usize, b: usize) {
        let ra = find(parent, a);
        let rb = find(parent, b);
        if ra != rb {
            parent[rb] = ra;
        }
    }

    // Compare all pairs; merge if similarity >= threshold
    for i in 0..n {
        for j in (i + 1)..n {
            let sim = structural_similarity(
                &embeddings[i],
                &neighbor_sets[i],
                &embeddings[j],
                &neighbor_sets[j],
            );
            if sim >= config.threshold {
                union(&mut parent, i, j);
            }
        }
    }

    // Collect clusters from union-find
    let mut cluster_map: std::collections::HashMap<usize, Vec<usize>> =
        std::collections::HashMap::new();
    for i in 0..n {
        let root = find(&mut parent, i);
        cluster_map.entry(root).or_default().push(i);
    }

    let mut clusters: Vec<EntityCluster> = cluster_map
        .into_values()
        .map(|indices| {
            let ids = indices.iter().map(|&i| candidate_ids[i]).collect();
            EntityCluster {
                member_indices: indices,
                member_ids: ids,
            }
        })
        .collect();

    // Sort clusters by first member index for deterministic output
    clusters.sort_by_key(|c| c.member_indices[0]);

    Ok(clusters)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{Config, Edge, InsertStats, Node, NodeType};
    use std::collections::HashMap;

    /// Minimal in-memory StorageEngine for testing entity resolution.
    struct MockEngine {
        nodes: HashMap<NodeId, Node>,
        adj: HashMap<NodeId, Vec<NodeId>>,
    }

    impl MockEngine {
        fn new() -> Self {
            Self {
                nodes: HashMap::new(),
                adj: HashMap::new(),
            }
        }

        fn add_node(&mut self, node: Node) {
            self.nodes.insert(node.id, node);
        }

        fn add_edge_directed(&mut self, src: NodeId, tgt: NodeId) {
            self.adj.entry(src).or_default().push(tgt);
            self.adj.entry(tgt).or_default().push(src);
        }
    }

    impl StorageEngine for MockEngine {
        fn init(_config: &Config) -> Result<Self> {
            Ok(Self::new())
        }

        fn insert_nodes(&mut self, nodes: &[Node]) -> Result<InsertStats> {
            for node in nodes {
                self.nodes.insert(node.id, node.clone());
            }
            Ok(InsertStats { count: nodes.len(), duration_us: 0 })
        }

        fn insert_edges(&mut self, edges: &[Edge]) -> Result<InsertStats> {
            for edge in edges {
                self.adj.entry(edge.source).or_default().push(edge.target);
                self.adj.entry(edge.target).or_default().push(edge.source);
            }
            Ok(InsertStats { count: edges.len(), duration_us: 0 })
        }

        fn get_node(&self, id: NodeId) -> Result<Option<Node>> {
            Ok(self.nodes.get(&id).cloned())
        }

        fn get_neighbors(&self, id: NodeId, hops: u8) -> Result<Vec<Node>> {
            if hops == 0 {
                return Ok(Vec::new());
            }
            let mut result = Vec::new();
            if let Some(neighbors) = self.adj.get(&id) {
                for &nid in neighbors {
                    if let Some(node) = self.nodes.get(&nid) {
                        result.push(node.clone());
                    }
                }
            }
            Ok(result)
        }

        fn vector_search(&self, _query: &[f32], _top_k: usize) -> Result<Vec<(NodeId, f32)>> {
            Ok(Vec::new())
        }

        fn hybrid_search(&self, _query: &[f32], _top_k: usize, _hops: u8) -> Result<Vec<Node>> {
            Ok(Vec::new())
        }

        fn find_path(&self, _source: NodeId, _target: NodeId, _max_depth: u32) -> Result<Option<Vec<NodeId>>> {
            Ok(None) // not needed for entity resolution tests
        }

        fn shutdown(&mut self) -> Result<()> {
            Ok(())
        }
    }

    fn make_node(id: NodeId, content: &str, embedding: Vec<f32>) -> Node {
        Node {
            id,
            content: content.to_string(),
            embedding,
            metadata: HashMap::new(),
            node_type: NodeType::Entity,
            timestamp: 1000,
            media_type: None,
            media_uri: None,
            embedding_visual: None,
            timestamp_range: None,
            parent_video_id: None,
        }
    }

    /// Create a simple embedding that has specific cosine similarity properties.
    /// Uses a unit vector pointing in the given direction index within 384-dim space.
    fn unit_vec(dim: usize, idx: usize) -> Vec<f32> {
        let mut v = vec![0.0f32; dim];
        v[idx] = 1.0;
        v
    }

    // ---------------------------------------------------------------
    // Jaccard similarity tests
    // ---------------------------------------------------------------

    #[test]
    fn test_jaccard_identical_sets() {
        let a: HashSet<NodeId> = [1, 2, 3].into_iter().collect();
        let b: HashSet<NodeId> = [1, 2, 3].into_iter().collect();
        assert!((jaccard_similarity(&a, &b) - 1.0).abs() < 1e-6);
    }

    #[test]
    fn test_jaccard_disjoint_sets() {
        let a: HashSet<NodeId> = [1, 2, 3].into_iter().collect();
        let b: HashSet<NodeId> = [4, 5, 6].into_iter().collect();
        assert!((jaccard_similarity(&a, &b) - 0.0).abs() < 1e-6);
    }

    #[test]
    fn test_jaccard_partial_overlap() {
        let a: HashSet<NodeId> = [1, 2, 3].into_iter().collect();
        let b: HashSet<NodeId> = [2, 3, 4].into_iter().collect();
        // intersection = {2,3} = 2, union = {1,2,3,4} = 4
        assert!((jaccard_similarity(&a, &b) - 0.5).abs() < 1e-6);
    }

    #[test]
    fn test_jaccard_empty_sets() {
        let a: HashSet<NodeId> = HashSet::new();
        let b: HashSet<NodeId> = HashSet::new();
        assert!((jaccard_similarity(&a, &b) - 0.0).abs() < 1e-6);
    }

    // ---------------------------------------------------------------
    // Cosine similarity tests
    // ---------------------------------------------------------------

    #[test]
    fn test_cosine_identical() {
        let v = unit_vec(384, 0);
        assert!((cosine_similarity(&v, &v) - 1.0).abs() < 1e-6);
    }

    #[test]
    fn test_cosine_orthogonal() {
        let a = unit_vec(384, 0);
        let b = unit_vec(384, 1);
        assert!((cosine_similarity(&a, &b) - 0.0).abs() < 1e-6);
    }

    // ---------------------------------------------------------------
    // structural_similarity tests
    // ---------------------------------------------------------------

    #[test]
    fn test_structural_similarity_identical_context() {
        let emb = unit_vec(384, 0);
        let neighbors: HashSet<NodeId> = [10, 20, 30].into_iter().collect();
        let sim = structural_similarity(&emb, &neighbors, &emb, &neighbors);
        // jaccard = 1.0, cosine = 1.0 → 0.6*1.0 + 0.4*1.0 = 1.0
        assert!((sim - 1.0).abs() < 1e-6);
    }

    #[test]
    fn test_structural_similarity_completely_different() {
        let emb_a = unit_vec(384, 0);
        let emb_b = unit_vec(384, 1);
        let neighbors_a: HashSet<NodeId> = [10, 20, 30].into_iter().collect();
        let neighbors_b: HashSet<NodeId> = [40, 50, 60].into_iter().collect();
        let sim = structural_similarity(&emb_a, &neighbors_a, &emb_b, &neighbors_b);
        // jaccard = 0.0, cosine = 0.0 → 0.0
        assert!((sim - 0.0).abs() < 1e-6);
    }

    // ---------------------------------------------------------------
    // Mandatory Apple test case (US-3.2 PRD requirement)
    // ---------------------------------------------------------------

    #[test]
    fn test_apple_entity_resolution() {
        // PRD test case:
        // 1. "Apple" with neighbors [Comer, Fruta, Roja] (fruit context)
        // 2. "Apple" with neighbors [iPhone, Tim Cook, Silicon Valley] (company context)
        // The system must separate them into 2 distinct clusters.

        let mut engine = MockEngine::new();

        // Apple (fruit) — node 1
        // Use embedding pointing in direction 0 (fruit-like)
        engine.add_node(make_node(1, "Apple", unit_vec(384, 0)));
        // Apple (company) — node 2
        // Use embedding pointing in direction 1 (tech-like)
        engine.add_node(make_node(2, "Apple", unit_vec(384, 1)));

        // Fruit context neighbors
        engine.add_node(make_node(10, "Comer", unit_vec(384, 10)));
        engine.add_node(make_node(11, "Fruta", unit_vec(384, 11)));
        engine.add_node(make_node(12, "Roja", unit_vec(384, 12)));

        // Company context neighbors
        engine.add_node(make_node(20, "iPhone", unit_vec(384, 20)));
        engine.add_node(make_node(21, "Tim Cook", unit_vec(384, 21)));
        engine.add_node(make_node(22, "Silicon Valley", unit_vec(384, 22)));

        // Connect Apple-fruit to fruit neighbors
        engine.add_edge_directed(1, 10); // Apple-fruit → Comer
        engine.add_edge_directed(1, 11); // Apple-fruit → Fruta
        engine.add_edge_directed(1, 12); // Apple-fruit → Roja

        // Connect Apple-company to company neighbors
        engine.add_edge_directed(2, 20); // Apple-company → iPhone
        engine.add_edge_directed(2, 21); // Apple-company → Tim Cook
        engine.add_edge_directed(2, 22); // Apple-company → Silicon Valley

        let config = EntityResolutionConfig::default();
        let clusters = resolve_entities(&engine, &[1, 2], &config).unwrap();

        assert_eq!(
            clusters.len(),
            2,
            "Apple (fruit) and Apple (company) must be in separate clusters"
        );

        // Each cluster should contain exactly 1 member
        assert_eq!(clusters[0].member_ids.len(), 1);
        assert_eq!(clusters[1].member_ids.len(), 1);

        // One cluster has node 1, the other has node 2
        let all_ids: HashSet<NodeId> = clusters
            .iter()
            .flat_map(|c| c.member_ids.iter().copied())
            .collect();
        assert!(all_ids.contains(&1));
        assert!(all_ids.contains(&2));
    }

    #[test]
    fn test_merge_same_entity_shared_neighbors() {
        // Two nodes with the same name, same embedding, and shared neighbors
        // should be merged into one cluster.

        let mut engine = MockEngine::new();

        let emb = unit_vec(384, 5);
        engine.add_node(make_node(1, "Paris", emb.clone()));
        engine.add_node(make_node(2, "Paris", emb));

        // Shared neighbors
        engine.add_node(make_node(10, "France", unit_vec(384, 10)));
        engine.add_node(make_node(11, "Eiffel Tower", unit_vec(384, 11)));
        engine.add_node(make_node(12, "Seine", unit_vec(384, 12)));

        engine.add_edge_directed(1, 10);
        engine.add_edge_directed(1, 11);
        engine.add_edge_directed(1, 12);

        engine.add_edge_directed(2, 10);
        engine.add_edge_directed(2, 11);
        engine.add_edge_directed(2, 12);

        let config = EntityResolutionConfig::default();
        let clusters = resolve_entities(&engine, &[1, 2], &config).unwrap();

        assert_eq!(
            clusters.len(),
            1,
            "Two 'Paris' nodes with identical context should merge into one cluster"
        );
        assert_eq!(clusters[0].member_ids.len(), 2);
    }

    #[test]
    fn test_single_candidate_returns_one_cluster() {
        let mut engine = MockEngine::new();
        engine.add_node(make_node(1, "Solo", unit_vec(384, 0)));

        let clusters = resolve_entities(
            &engine,
            &[1],
            &EntityResolutionConfig::default(),
        )
        .unwrap();

        assert_eq!(clusters.len(), 1);
        assert_eq!(clusters[0].member_ids, vec![1]);
    }

    #[test]
    fn test_empty_candidates_returns_empty() {
        let engine = MockEngine::new();
        let clusters = resolve_entities(
            &engine,
            &[],
            &EntityResolutionConfig::default(),
        )
        .unwrap();
        assert!(clusters.is_empty());
    }

    #[test]
    fn test_three_way_clustering() {
        // 3 candidates: two should cluster (shared context), one should separate
        let mut engine = MockEngine::new();

        // Two "Mercury" nodes in astronomy context
        engine.add_node(make_node(1, "Mercury", unit_vec(384, 0)));
        engine.add_node(make_node(2, "Mercury", unit_vec(384, 0)));
        // One "Mercury" node in chemistry context
        engine.add_node(make_node(3, "Mercury", unit_vec(384, 1)));

        // Shared astronomy neighbors
        engine.add_node(make_node(10, "Planet", unit_vec(384, 10)));
        engine.add_node(make_node(11, "Solar System", unit_vec(384, 11)));

        // Chemistry neighbors (disjoint)
        engine.add_node(make_node(20, "Element", unit_vec(384, 20)));
        engine.add_node(make_node(21, "Liquid Metal", unit_vec(384, 21)));

        engine.add_edge_directed(1, 10);
        engine.add_edge_directed(1, 11);
        engine.add_edge_directed(2, 10);
        engine.add_edge_directed(2, 11);

        engine.add_edge_directed(3, 20);
        engine.add_edge_directed(3, 21);

        let config = EntityResolutionConfig::default();
        let clusters = resolve_entities(&engine, &[1, 2, 3], &config).unwrap();

        assert_eq!(
            clusters.len(),
            2,
            "Astronomy Mercurys should cluster together, chemistry Mercury should be separate"
        );

        // Find which cluster has 2 members (astronomy) and which has 1 (chemistry)
        let big_cluster = clusters.iter().find(|c| c.member_ids.len() == 2).unwrap();
        let small_cluster = clusters.iter().find(|c| c.member_ids.len() == 1).unwrap();

        assert!(big_cluster.member_ids.contains(&1));
        assert!(big_cluster.member_ids.contains(&2));
        assert_eq!(small_cluster.member_ids, vec![3]);
    }

    #[test]
    fn test_custom_threshold() {
        // With a very high threshold (1.0), even identical nodes won't merge
        // (unless they have perfect overlap)
        let mut engine = MockEngine::new();

        let emb = unit_vec(384, 0);
        engine.add_node(make_node(1, "X", emb.clone()));
        engine.add_node(make_node(2, "X", emb));

        // Partial neighbor overlap
        engine.add_node(make_node(10, "A", unit_vec(384, 10)));
        engine.add_node(make_node(11, "B", unit_vec(384, 11)));
        engine.add_node(make_node(12, "C", unit_vec(384, 12)));

        engine.add_edge_directed(1, 10);
        engine.add_edge_directed(1, 11);
        engine.add_edge_directed(2, 11);
        engine.add_edge_directed(2, 12);

        // With high threshold, partial overlap won't merge
        let strict_config = EntityResolutionConfig { threshold: 0.95 };
        let clusters = resolve_entities(&engine, &[1, 2], &strict_config).unwrap();
        // jaccard = 1/3 ≈ 0.33, cosine = 1.0 → combined = 0.6*0.33 + 0.4*1.0 = 0.6
        // 0.6 < 0.95 → should NOT merge
        assert_eq!(clusters.len(), 2, "Strict threshold should prevent merging");

        // With low threshold, they should merge
        let lenient_config = EntityResolutionConfig { threshold: 0.5 };
        let clusters = resolve_entities(&engine, &[1, 2], &lenient_config).unwrap();
        assert_eq!(clusters.len(), 1, "Lenient threshold should allow merging");
    }
}
